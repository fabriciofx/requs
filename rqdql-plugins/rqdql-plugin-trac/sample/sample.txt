;;; Define a lexical analyser generator function.  This function takes
;;; a string and optionally the start and end positions, and returns
;;; a function of no parameters that returns the two values token and
;;; value each time it is called.  When the string is exhausted, it
;;; returns (values nil nil)
[hithere]
;;;
;;; These lexers are compatible with the lispworks parser generator.
;;;
;;; If you need to parse a stream, then just load the stream into a
;;; string and hand it to the parser.  Or do it a line-at-a-time if
;;; you need a more incremental parser.
;;;
;;; This version uses the new regex compiler to good effect.  It
;;; parses out each pattern, then combines them all into one big
;;; pattern that is rigged to
;;;


(defmacro deflexer (name &rest rules)
  "Create a [lexical] analyser.  This analyser function takes a string :position,
:end, :end-token and :end-value keyword parameters, and returns a function of
no arguments that returns the next token and value each time it is called,
or (values end-token end-value) when the input string is exhausted.
By default, position = 0, end = length of str, and end-token and end-value = nil."
  (let ((matchervar (intern (concatenate 'string (symbol-name name) "-MATCHER")
                            *package*))
        (rcvar (gensym))
        (matchstartvar (gensym))
        (matchlenvar (gensym))
        (matchregsvar (gensym))
        (strvar (gensym))
        (prevposvar (gensym)))
    (multiple-value-bind (patterns actions)
        (extract-patterns-and-actions rules)
      `(progn
         (defparameter ,matchervar (macroexpand-regex-expr ',(combine-patterns patterns)))
         (defun ,name (,strvar &key (start 0)
                                    (end (length ,strvar))
                                    (end-token nil)
                                    (end-value nil)
                               &aux (,prevposvar -1)
                                    ,rcvar ,matchstartvar ,matchlenvar ,matchregsvar)
[commonlisp]
           (declare (string ,strvar) (fixnum start end))
	   ;; wiki haha
           (flet ((%n (n)
                    (let* ((rstart (regex:register-start ,matchregsvar n))
                           (rend (regex:register-end ,matchregsvar n)))
                      (if (and (numberp rstart) (numberp rend))
                          (subseq ,strvar rstart rend))))
                  (nextch ()
                    (when (< start end)
                      (prog1
                          (char ,strvar start)
                        (incf start)
                        )))
			;;wiki
                  (ungetch (ch)
                    (when (and (characterp ch) (> start 0))
                      (decf start)
                      )))
		      ;; yet another wiki
             (symbol-macrolet ((%0 (%n 0)) (%1 (%n 1)) (%2 (%n 2)) (%3 (%n 3))
                               (%4 (%n 4)) (%5 (%n 5)) (%6 (%n 6)) (%7 (%n 7))
                               (%8 (%n 8)) (%9 (%n 9)) (%10 (%n 10)))
<start>
               (lambda ()
                 (loop while (< start end)
                       when (= start ,prevposvar)
                       do (error "Lexer unable to recognize a token in ~S, position ~D (~S)"
                                 ,strvar start
                                 (subseq ,strvar start (min end (+ start 20))))
                       do (progn
                            (setq ,prevposvar start)
                            (multiple-value-setq (,rcvar ,matchstartvar ,matchlenvar ,matchregsvar)
                                (match-str ,matchervar ,strvar :start start))
                            (if ,rcvar
                                (incf start ,matchlenvar)
                              (error "~A lexing failure (no token recognized) in ~S @ ~D"
                                     ',name ,strvar start))
<end>
                            (case ,rcvar
                              ,@(make-lexer-actions actions)
                              (otherwise
                               (error "~A lexing failure (unknown token) in ~S @ ~D, ~S ~S ~S ~S"
                                      ',name ,strvar start
                                      ,rcvar ,matchstartvar ,matchlenvar ,matchregsvar))))
                       finally (return (values end-token end-value)))))))))))
#+:Lispworks (editor:setup-indent "deflexer" 1 2 10)
<start>
; Pull out the patterns and actions, with rule numbers so we can keep them associated
(defun extract-patterns-and-actions (rules &aux patterns actions)
<end>
  (loop for rule in rules
        for rulenum from 0
        for pat = (first rule)
        for action = (rest rule)
	;; wiki
        do (progn
             (push `(,pat ,rulenum) patterns)
             (push `(,action ,rulenum) actions))
        finally (return (values (nreverse patterns) (nreverse actions)))))
