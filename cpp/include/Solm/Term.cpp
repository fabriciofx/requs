/**
 * RQDQL.com, Requirements Definition and Query Language
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are PROHIBITED without prior written 
 * permission from the author. This product may NOT be used 
 * anywhere and on any computer except the server platform of 
 * rqdql.com. located at www.rqdql.com. If you received this 
 * code occasionally and without intent to use it, please report 
 * this incident to the author by email: team@rqdql.com
 *
 * @author Yegor Bugayenko <egor@tpc2.com>
 * @copyright Copyright (c) rqdql.com, 2010
 * @version $Id$
 */

#include <string>
#include <vector>
#include <boost/format.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/regex.hpp>
#include <boost/scope_exit.hpp>
#include "Solm/Term.h"
#include "rqdql.h"
#include "rqdql/Exception.h"

using std::string;

/**
 * These files are auto-generated by FLEX/BISON tools called from
 * Makefile. Without these files we can't proceed here
 * and compilation will be failed.
 */
#include "Solm/Term/lisp.y.c-symbols.h"

/**
 * Declaration here, implementation later
 */
void termerror(const char*, ...);

/**
 * Global variable, to be used as a target for BISON parser
 *
 * This approach is NOT thread-safe, but good enough for now
 */
solm::Term::Term* term_target;

/**
 * These files are auto-generated by FLEX/BISON tools called from
 * Makefile. Without these files we can't proceed here
 * and compilation will be failed.
 */
#include "Solm/Term/lisp.l.c"
#include "Solm/Term/lisp.y.c"

solm::Term::Term(const string& s) : _terms() {
    /**
     * If nothing provided we assume that it's a simple term TRUE
     * and we should skip all syntax analysis and processing.
     */
    if (s.empty()) {
        _value = "true";
        return;
    }
    
    /**
     * We can't start this function if the same function is already
     * running. If we do this, we will break the BISON parser.
     */
    if (term_target) {
        throw rqdql::Exception(
            rqdql::_t("You can't start Term() from itself")
        );
    }
    
    /**
     * This variable is used by the parser.
     */
    term_target = this;

    /**
     * Drop this link to NULL once the execution is finished. We should
     * execute this procedure in any case, no matter whether we finish this
     * function with success or exception.
     */
    BOOST_SCOPE_EXIT( (&term_target) ) {
        term_target = 0;
    } BOOST_SCOPE_EXIT_END
        
    try {
        term_switch_to_buffer(term_scan_string(s.c_str()));
        termparse();
    } catch (string ex) {
        /**
         * This exception will be thrown by termerror(), see
         * the end of this file. termparse() calls this termerror()
         * function when it finds some problem in parsing.
         */
        throw rqdql::Exception(
            boost::format(rqdql::_t("Invalid TERM '%s' (%s)")) % s % ex
        );
    }
}

bool solm::Term::operator==(const solm::Term& t) const {
    if (_value != t._value) {
        return false;
    }
    if (_terms.size() != t._terms.size()) {
        return true;
    }
    return equal(_terms.begin(), _terms.end(), t._terms.begin());
}

bool solm::Term::is(solm::Term::Kind k) const {
    switch (k) {
        case T_ATOM:
            return (is(T_OBJECT) || is(T_VARIABLE) || is(T_NUMBER) || is(T_TEXT)) && !_terms.size();
        case T_NUMBER:
            return boost::regex_match(_value, boost::regex("[\\-\\+]?[0-9]+(\\.[0-9]+)?"));
        case T_TEXT:
            return boost::regex_match(_value, boost::regex("'.*'"));
        case T_OBJECT:
            return boost::regex_match(_value, boost::regex("[a-z_][a-zA-Z0-9_]*"));
        case T_VARIABLE:
            return boost::regex_match(_value, boost::regex("[A-Z][a-zA-Z0-9_]*"));
        case T_FALSE:
            return _value == "false";
        case T_TRUE:
            return _value == "true";
        default:
            return false;
    }
}

solm::Term::operator string() const {
    if (!_terms.size()) {
        return _value;
    }
    
    std::vector<string> v;
    for (std::vector<Term>::const_iterator i = _terms.begin(); i != _terms.end(); ++i) {
        v.push_back((string)(*i));
    }
    return "(" + _value + " " + boost::algorithm::join(v, " ") + ")";
}

const solm::Term solm::Term::operator*(const solm::Term& t) {
    return Term();
}

solm::Term::Term(const string& v, const solm::Term::Terms& t) : _value(v), _terms(t) {
    /* that's it */
}

void termerror(const char* s, ...) {
    throw string(s);
}
