\documentclass{article}
\usepackage{listings} % listings
    \lstset{
        basicstyle=\small\ttfamily,
        numbers=left,
        numberstyle=\scriptsize,
        firstnumber=1,
        stepnumber=4,
        numbersep=1em,
        aboveskip=2em,
        belowskip=1em,
        lineskip=-0.3em,
        frame=leftline,
    }
\usepackage{color}
\usepackage{tikz}
	\usetikzlibrary{shapes,arrows,shadows}
	\usetikzlibrary{decorations.pathmorphing}
	\usetikzlibrary{positioning}
	\usetikzlibrary{fit}
	\usetikzlibrary{trees} % for grow cyclic

\begin{document}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}
\newcommand{\type}[1]{\mbox{\texttt{#1}}}
\newenvironment{maths}
{
    \vspace*{0.5em}
    \begin{tabular}{l}
}
{
    \end{tabular}
    \vspace*{1em}
}

\title{RQDQL: White Paper}
\author{
    Yegor Bugayenko\\
    \texttt{yegor@tpc2.com}
}
\maketitle

\newpage
\section{Classes}

    Verbal form of a type/class (C++ as an example):

    \begin{verbatim}
User includes:
  email: "email address";
  photo-s: Photo "a collection of photos";
  manager: User "user's manager, if any";
  address includes: city, country, street.\end{verbatim}

    Formal ($\Pi_i$ is a set):
    
    \begin{maths}
    $\type{User}(x) :$ \\
    $\quad \exists \Pi_1 (|\Pi_1| = 1 \wedge$ \\
    $\quad\quad \forall p(p \in \Pi_1 \to $ \\
    $\quad\quad\quad \type{string}(p) \wedge$ \\
    $\quad\quad\quad \type{composition}(x, p) \wedge$ \\
    $\quad\quad\quad \type{info}(\mbox{``email address''})$ \\
    $\quad\quad ) $ \\
    $\quad ) \bigwedge $ \\
    $\quad \exists \Pi_2 (|\Pi_2| \geq 0 \wedge$ \\
    $\quad\quad \forall p(p \in \Pi_2 \to $ \\
    $\quad\quad\quad \type{Photo}(p) \wedge$ \\
    $\quad\quad\quad \type{composition}(x, p) \wedge$ \\
    $\quad\quad\quad \type{info}(\mbox{``a collection of photos''})$ \\
    $\quad\quad ) $ \\
    $\quad ) \bigwedge $ \\
    $\quad \exists \Pi_3 (|\Pi_4| < 2 \wedge $ \\
    $\quad\quad \forall p(p \in \Pi_4 \to $ \\
    $\quad\quad \type{User}(p) \wedge$ \\
    $\quad\quad \type{aggregation}(x, p) \wedge$ \\
    $\quad\quad \type{info}(\mbox{``user's manager, if any''})$ \\
    $\quad\quad ) $ \\
    $\quad ) \bigwedge $ \\
    $\quad \exists \Pi_4 (|\Pi_4| = 1 \wedge$ \\
    $\quad\quad \forall p(p \in \Pi_4 \to$ \\
    $\quad\quad\quad \exists \Psi_1(|\Psi_1|=1 \wedge \forall \psi(\psi \in \Psi_1 \to \type{string}(\psi) \wedge \type{composition}(p, \psi))) \wedge$ \\
    $\quad\quad\quad \exists \Psi_2(|\Psi_2|=1 \wedge \forall \psi(\psi \in \Psi_2 \to \type{string}(\psi) \wedge \type{composition}(p, \psi))) \wedge$ \\
    $\quad\quad\quad \exists \Psi_3(|\Psi_3|=1 \wedge \forall \psi(\psi \in \Psi_3 \to \type{string}(\psi) \wedge \type{composition}(p, \psi)))$ \\
    $\quad\quad ) $ \\
    $\quad )$ \\
    \end{maths}
    
    There are a number of sub-predicates:

    \begin{maths}
    $\type{User.email}(x, \Pi) = (|\Pi| = 1 \wedge \forall p(p \in \Pi \to \type{string}(p) \wedge \type{composition}(x, p))$ \\
    \end{maths}
    
\newpage
\section{Use Cases}

    Verbal form of a use case:
    
    \begin{verbatim}
    UC1: User (the user) extends photo album:
      1. The user creates photo of himself (the photo).
      2. We validate the photo "immediately".
      3. "We protocol the operation in backlog".
      4. The user reads the photo.
    UC1: 0a) If number of photos of the user is greater than 5:
      1. The user deletes photo of himself.
    UC1: 2a) If failed with "file format is not valid":
      1. We delete the photo.
      2. Fail with "only PNG images are accepted".\end{verbatim}

    Every use case is a predicate, $\type{UC}_1(x) = true$ means that the user
    successfully extended his photo album:
    
    \begin{maths}
    $\type{UC}_1(x) : $ \\
    $\quad \type{User}(x) \to$ \\
    $\quad \exists \Pi(\type{User.photo}(x, \Pi)) \to$ \\
    $\quad ($ \\
    $\quad\quad |\Pi| > 5 \wedge \type{info}(\mbox{``If number of photos of the user is greater than 5''})\to$ \\
    $\quad\quad \exists y(y \in \Pi) \to$ \\
    $\quad\quad \type{deleted}(y) \wedge \type{info}(\mbox{``The user deletes photo of himself''})$ \\
    $\quad ) \to$ \\
    $\quad \exists p(p \in \Pi) \to$ \\
    $\quad \type{created}(p, x) \wedge \type{info}(\mbox{``The user creates photo of himself (the photo)''})\to$ \\
    $\quad \type{UC}_2(p) \wedge \type{info}(\mbox{``We validate the photo immediately''}) \vee$ \\
    $\quad ($ \\
    $\quad\quad \type{exception}(\mbox{``file format is not valid''}) \to$ \\
    $\quad\quad \type{deleted}(p) \wedge \type{info}(\mbox{``We delete the photo''})\to$ \\
    $\quad\quad \type{throw}(\mbox{``only PNG images are accepted''})$ \\
    $\quad ) \to$ \\
    $\quad \type{silent}(\mbox{``We protocol the operation in backlog''})$ \\
    $\quad \type{read}(p, x)\wedge \type{info}(\mbox{``The user reads the photo''})$ \\
    \end{maths}
    
\newpage
\section{Basic Predicates}

    Basic fundamental predicates:

    \begin{maths}
    $\type{info}(x) = true$ \\
    $\type{composition}(x, y) = \dots$ \\
    $\type{aggregation}(x, y) = \dots$ \\
    $\type{created}(x) = \dots$ \\
    $\type{deleted}(x) = \dots$ \\
    $\type{read}(x) = \dots$ \\
    $\type{exception}(x) = \dots$ \\
    $\type{throw}(x) = \dots$ \\
    \end{maths}

    Primitive types:

    \begin{maths}
    $\type{integer}(x) = \dots$ \\
    $\type{string}(x) = \dots$ \\
    $\type{float}(x) = \dots$ \\
    $\type{boolean}(x) = \dots$ \\
    \end{maths}


\newpage
\section{Parser, Validator, Metric Collector, etc.}

    \begin{tikzpicture}
        [node distance=8em, thick]
        \node [draw] (yacc) {YACC};
        \node [draw, right of=yacc] (brokers) {C++ brokers};
        \node [draw, right of=brokers] (proxy) {Proxy};
        \node [draw, right of=proxy] (solm) {SOLM};

        \node [draw, below of=proxy] (logger) {Logger};
        \node [draw, right of=logger] (front) {Front};
        \node [draw, right of=front] (main) {\texttt{main()}};
        \node [draw, below of=main] (plugin) {RqdqlPlugin};
        
        \draw [->] (yacc) -- (brokers);
        \draw [->] (brokers) -- (proxy);
        \draw [->] (proxy) -- (solm);
        \draw [->] (main) -- (front);
        \draw [->] (front) -- (logger);
        \draw [->] (front) -- (solm);
        \draw [->] (plugin) -- (main);
        
        \draw [dashed, ->] (yacc) -- (logger);
        \draw [dashed, ->] (brokers) -- (logger);
        \draw [dashed, ->] (proxy) -- (logger);
        \draw [dashed, ->] (solm) -- (logger);
    \end{tikzpicture}
    

    SOLM is a collection of \emph{formulas}:

    \begin{tikzpicture}[
        every node/.style={class},
        level 1/.style={level distance=8em, sibling distance=10em, open triangle 90-},
        level 2/.style={sibling distance=5em},
        ]
        \tikzstyle{class} = [draw, text width=4em, font={\small\ttfamily}, fill=white, anchor=north];
        \newcommand{\br}{\linebreak\rule{3em}{0.4pt}\linebreak}
        \node {formula\br formula[]}
            child {node [dashed] {unary\br}
                child {node [dashed] {quantifier\br var[]}
                    child [level distance=4em] {node {forall}}
                    child [level distance=4em] {node {exists}}
                }
                child {node {declaration\br name\linebreak var[]}} 
            }
            child {node {sequence\br operand}
                child {node [dashed] {binary\br}
                    child {node {and\br}} 
                    child {node {or\br}} 
                }
            } 
            child {node [dashed] {predicate\br var[]}
                child {node {math\br operand}}
                child {node {function\br name}}
                child {node {primitive\br}}
            }
        ;
    \end{tikzpicture}
    
    \clearpage
    Proxy is a collection of C++ classes:
    
    \begin{lstlisting}[language=C++]
class Type {
  vector<solm::Formula*> predicates;
  vector<Slot> slots;
};
class Slot {
  string name;
  Cardinality cardinality;
  vector<solm::Formula*> predicates;
  Type* type;
};
map<string, Type> types; // all named types
class UseCase {
  class Signature {
    string format; // e.g. "${sud} validate ${photo}"
    map<string, Explanation> explanations; // e.g. <"photo", "User.photos">
  };
  Signature signature;
  typedef map<int, Flow> Flows;
  class Flow {
    string informal;
    Signature signature;
    map<solm::Formula*, Flows&> alternatives;
  };
};
\end{lstlisting}

    Front is a collection of components. Every component gets
    an associative array of configuration parameters 
    and returns an XML element. The element is named \texttt{<report>}
    and has attributes equivalent to the configuration
    params provided.
    
    \texttt{main()} returns an XML document that integrates
    all reports retrieved:
    
    \begin{lstlisting}[language=XML]
<?xml version="1.0" ?>
<rqdql>
  <errors>
    <report>
      <error>
        <lines>
          <line>23</line>
        </lines>
        <msg>
          This is an error
        </msg>
      </error>
    </report>
  </errors>
  <metrics>
    <report>
      <ambiguity>0.765</ambiguity>
    </report>
  </metrics>
  <uml>
    <report uc="UC6.5">
      <uml><[CDATA[....]]></uml>
    </report>
  </uml>
</rqdql>
    \end{lstlisting}

    The script shall be called from command line like this:
    
    \begin{lstlisting}[language=bash]
$ rqdql errors uml:uc=UC6.5 metrics < myscope.txt
    \end{lstlisting}
    
    Possible reports are:
    
    \begin{itemize}
        \item \texttt{errors}: full list of errors
        \item \texttt{metrics}: full analysis of the scope ambiguity, size, intensity, etc.
        \item \texttt{links}: report links between objects (line to line)
        \item \texttt{uml:uc=UC5,type=ActorUser,...}: description of types and use cases in UML
        \item \texttt{svg:uc=UC5,type=ActorUser,...}: description of types and use cases in SVG
        \item \texttt{tc:uc=UC5,...}: Test Cases for the given UC-s (or all)
    \end{itemize}
    
\newpage
\section{Test Cases}

    Every formula produces a number of ``fact sequences''. Every fact sequence
    is a vector of ``facts'', and every fact is either a positive or negative:
    
    \begin{tikzpicture}[
        node distance=4em,
        every node/.style={circle, draw},
        level 1/.style={},
        level 2/.style={},
        -triangle 60
        ]
        \tikzstyle{true} = [thick, font=\bfseries];
        \node[true] (t1) {t}
            child {node[true] (t2-1) {t}
                child {node[true] (t2-1-1) {t}
                    child {node[true] {t}
                        child {node[true] {t}}
                        child {node {f}}
                        child {node {f}}
                        child {node {f}}
                    }
                    child {node {f}}
                }
                child {node (t2-1-2) {f}}
                child {node (t2-1-3) {f}}
            }
            child {node (t2-2) {f}}
            child {node (t2-3) {f}}
        ;
        \node [right of=t1] (t2) {f};
        \node [right of=t2] (t3) {f};
        
        \node [draw=black, rectangle, rounded corners, fit=(t1) (t2) (t3)] (f1) {};
            \node [draw=none, anchor=east] at (f1.west) {formula 1};

        \node [draw=black, rectangle, rounded corners, fit=(t2-1) (t2-1-1) (t2-1-2) (t2-1-3) (t2-2) (t2-3)] (f2) {};
            \node [draw=none, anchor=east] at (f2.west) {formula 2};
    \end{tikzpicture}
    
    Every fact includes a ``snapshot'' of persistent data. Snapshot includes:
    objects. Every object
    has a name, value, type, 
    and may have a number of changes made by other objects:
    
    \begin{lstlisting}[language=C++]
class Object {
    int id; // could be zero
    string name; // could be empty
    string type; // mandatory
    Value* value; 
    vector<AclRule> rules;
};
class Value {};
    class ValueString : public Value {
        string value;
    };
    class ValueSet : public Value {
        vector<int> ids;
    };
    class ValueAssociation : public Value, 
        public pair<AssociationMember, AssociationMember> {};
        class AssociationMember {};
            class AssociationMemberId : public AssociationMember {
                int id;
            };
            class AssociationMemberName : public AssociationMember {
                string name;
            };
class AclRule {
    enum {CREATE, READ, UPDATE, DELETE} operation;
    int id;
};
vector<Object> snapshot;
\end{lstlisting}

    Consider this example:

    \def\chng#1{\colorbox{lightgray}{#1}}
    \begin{tabular}[t]{l|lllll}
        SOLM formula & \multicolumn{5}{l}{Snapshots} \\
        & Name & Type & ID & Value & ACL Rules \\
        \hline

        $\type{UC}_1(x) : $ \\
        $\quad \type{User}(x) \to$ 
            & \chng{$x$} & \chng{\texttt{User}} & \chng{\texttt{1}} \\
        
        \hline
        $\quad \exists \Pi(\type{User.photo}(x, \Pi)) \to$ 
            & $x$ & \texttt{User} & \texttt{1} \\
            & \chng{$\Pi$} & \chng{\texttt{Photo}} & & \chng{\texttt{[?]}} \\
            &  & \chng{\texttt{User.photo}} & & \chng{\texttt{1:$\Pi$}} \\
        
        \hline
        $\quad ($ \\
        $\quad\quad |\Pi| > 5 \to$ 
            & $x$ & \texttt{User} & \texttt{1} \\
            & $\Pi$ & \texttt{Photo} & & \texttt{[\chng{2}]} \\
            &  & \chng{\texttt{Photo}} & \chng{\texttt{2}} \\
            & & \texttt{User.photo} & & \chng{\texttt{1:2}} \\
            
        \hline
        $\quad\quad \exists y(y \in \Pi) \to$ \\
        $\quad\quad \type{deleted}(y) $ \\
        $\quad ) \to$
            & \multicolumn{4}{l}{\textit{skipped}} \\
            
        \hline
        $\quad \exists p(p \in \Pi) \to$ 
            & $x$ & \texttt{User} & \texttt{1} \\
            & $\Pi$ & \texttt{Photo} & & \texttt{[2]} \\
            & \chng{$p$} & \texttt{Photo} & \texttt{2} \\
            &  & \texttt{User.photo} & & \texttt{1:2} \\
            
        \hline
        $\quad \type{created}(p, x) \to$
            & $x$ & \texttt{User} & \texttt{1} \\
            & $\Pi$ & \texttt{Photo} & & \texttt{[2\chng{,3}]} \\
            & \chng{---} & \texttt{Photo} & \texttt{2} \\
            & \chng{$p$} & \chng{\texttt{Photo}} & \chng{\texttt{3}} & & \chng{\texttt{CREATE:1}} \\
            & & \texttt{User.photo} & & \texttt{1:2} \\
            & & \chng{\texttt{User.photo}} & & \chng{\texttt{1:3}} \\
            
        \hline
        $\quad \type{UC}_2(p) \vee$ \\
        $\quad ($ \\
        $\quad\quad \type{exception}(\mbox{``file format...''}) \to$ \\
        $\quad\quad \type{deleted}(p) \to$ \\
        $\quad\quad \type{throw}(\mbox{``only PNG...''})$ \\
        $\quad ) \to$
            & \multicolumn{5}{l}{\textit{skipped}} \\
        
        \hline
        $\quad \type{silent}(\mbox{``We protocol...''})$ \\
        $\quad \type{read}(p, x) $
            & $x$ & \texttt{User} & \texttt{1} \\
            & $\Pi$ & \texttt{Photo} & & \texttt{[2,3]} \\
            &  & \texttt{Photo} & \texttt{2} \\
            & $p$ & \texttt{Photo} & \texttt{3} & & \texttt{CREATE:1}\chng{,} \\
            &     &                &            & & \chng{\texttt{READ:1}} \\
            & & \texttt{User.photo} & & \texttt{1:2} \\
            & & \texttt{User.photo} & & \texttt{1:3} \\
            & & \chng{\texttt{silent}} & \chng{\texttt{4}} &
                \chng{\parbox[t]{5em}{\raggedright``We protocol...''}} \\
        
    \end{tabular}

    Next, we can calculate the difference between two snapshots. This difference
    will become a single step in a ``test case''.

\end{document}
